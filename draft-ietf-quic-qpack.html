<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>QPACK: Header Compression for HTTP over QUIC</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre {
  font: 15px Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Header Tables">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Static Table">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Dynamic Table">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Absolute and Relative Indexing">
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Post-Base Indexing">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Avoiding Head-of-Line Blocking in HTTP/QUIC">
<link href="#rfc.section.2.3.1" rel="Chapter" title="2.3.1 State Synchronization">
<link href="#rfc.section.3" rel="Chapter" title="3 Conventions and Definitions">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Notational Conventions">
<link href="#rfc.section.4" rel="Chapter" title="4 Configuration">
<link href="#rfc.section.5" rel="Chapter" title="5 Wire Format">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Primitives">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Prefixed Integers">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 String Literals">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 QPACK Encoder Stream">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Insert With Name Reference">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Insert Without Name Reference">
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 Duplicate">
<link href="#rfc.section.5.2.4" rel="Chapter" title="5.2.4 Dynamic Table Size Update">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 QPACK Decoder Stream">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Table State Synchronize">
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 Header Acknowledgement">
<link href="#rfc.section.5.3.3" rel="Chapter" title="5.3.3 Stream Cancellation">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Request and Push Streams">
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 Header Data Prefix">
<link href="#rfc.section.5.4.2" rel="Chapter" title="5.4.2 Instructions">
<link href="#rfc.section.6" rel="Chapter" title="6 Error Handling">
<link href="#rfc.section.7" rel="Chapter" title="7 Encoding Strategies">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Single Pass Encoding">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Preventing Eviction Races">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Reference Tracking">
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 Blocked Eviction">
<link href="#rfc.section.7.3.2" rel="Chapter" title="7.3.2 Blocked Decoding">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Speculative table updates">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Sample One Pass Encoding Algorithm">
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 IANA Considerations">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Settings Registration">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Stream Type Registration">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Error Code Registration">
<link href="#rfc.references" rel="Chapter" title="10 References">
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Change Log">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Since draft-ietf-quic-qpack-01">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Since draft-ietf-quic-qpack-00">
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 Since draft-ietf-quic-qcram-00">
<link href="#rfc.acknowledgments" rel="Chapter">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.9 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Krasic, C., Bishop, M., and A. Frindell, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-qpack-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-08-17" />
  <meta name="dct.abstract" content="This specification defines QPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP over QUIC. This is a variation of HPACK header compression that seeks to reduce head-of-line blocking." />
  <meta name="description" content="This specification defines QPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP over QUIC. This is a variation of HPACK header compression that seeks to reduce head-of-line blocking." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">QUIC</td>
<td class="right">C. Krasic</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Netflix</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">M. Bishop</td>
</tr>
<tr>
<td class="left">Expires: February 18, 2019</td>
<td class="right">Akamai Technologies</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">A. Frindell, Ed.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Facebook</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">August 17, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">QPACK: Header Compression for HTTP over QUIC<br />
  <span class="filename">draft-ietf-quic-qpack-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This specification defines QPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP over QUIC. This is a variation of HPACK header compression that seeks to reduce head-of-line blocking.</p>
<h1><a>Note to Readers</a></h1>
<p>Discussion of this draft takes place on the QUIC working group mailing list (quic@ietf.org), which is archived at <a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a>.</p>
<p>Working Group information can be found at <a href="https://github.com/quicwg">https://github.com/quicwg</a>; source code and issues list for this draft can be found at <a href="https://github.com/quicwg/base-drafts/labels/-qpack">https://github.com/quicwg/base-drafts/labels/-qpack</a>.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on February 18, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Header Tables</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Static Table</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Dynamic Table</a>
</li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Absolute and Relative Indexing</a>
</li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Post-Base Indexing</a>
</li>
</ul><li>2.3.   <a href="#rfc.section.2.3">Avoiding Head-of-Line Blocking in HTTP/QUIC</a>
</li>
<ul><li>2.3.1.   <a href="#rfc.section.2.3.1">State Synchronization</a>
</li>
</ul></ul><li>3.   <a href="#rfc.section.3">Conventions and Definitions</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Notational Conventions</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Configuration</a>
</li>
<li>5.   <a href="#rfc.section.5">Wire Format</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Primitives</a>
</li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">Prefixed Integers</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">String Literals</a>
</li>
</ul><li>5.2.   <a href="#rfc.section.5.2">QPACK Encoder Stream</a>
</li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Insert With Name Reference</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Insert Without Name Reference</a>
</li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">Duplicate</a>
</li>
<li>5.2.4.   <a href="#rfc.section.5.2.4">Dynamic Table Size Update</a>
</li>
</ul><li>5.3.   <a href="#rfc.section.5.3">QPACK Decoder Stream</a>
</li>
<ul><li>5.3.1.   <a href="#rfc.section.5.3.1">Table State Synchronize</a>
</li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">Header Acknowledgement</a>
</li>
<li>5.3.3.   <a href="#rfc.section.5.3.3">Stream Cancellation</a>
</li>
</ul><li>5.4.   <a href="#rfc.section.5.4">Request and Push Streams</a>
</li>
<ul><li>5.4.1.   <a href="#rfc.section.5.4.1">Header Data Prefix</a>
</li>
<li>5.4.2.   <a href="#rfc.section.5.4.2">Instructions</a>
</li>
</ul></ul><li>6.   <a href="#rfc.section.6">Error Handling</a>
</li>
<li>7.   <a href="#rfc.section.7">Encoding Strategies</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Single Pass Encoding</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Preventing Eviction Races</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Reference Tracking</a>
</li>
<ul><li>7.3.1.   <a href="#rfc.section.7.3.1">Blocked Eviction</a>
</li>
<li>7.3.2.   <a href="#rfc.section.7.3.2">Blocked Decoding</a>
</li>
</ul><li>7.4.   <a href="#rfc.section.7.4">Speculative table updates</a>
</li>
<li>7.5.   <a href="#rfc.section.7.5">Sample One Pass Encoding Algorithm</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Security Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">IANA Considerations</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Settings Registration</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Stream Type Registration</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Error Code Registration</a>
</li>
</ul><li>10.   <a href="#rfc.references">References</a>
</li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Change Log</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Since draft-ietf-quic-qpack-01</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">Since draft-ietf-quic-qpack-00</a>
</li>
<li>A.3.   <a href="#rfc.appendix.A.3">Since draft-ietf-quic-qcram-00</a>
</li>
</ul><li><a href="#rfc.acknowledgments">Acknowledgments</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The QUIC transport protocol was designed from the outset to support HTTP semantics, and its design subsumes many of the features of HTTP/2.  HTTP/2 uses HPACK (<a href="#RFC7541" class="xref">[RFC7541]</a>) for header compression, but QUIC&#8217;s stream multiplexing comes into some conflict with HPACK.  A key goal of the design of QUIC is to improve stream multiplexing relative to HTTP/2 by reducing head-of-line blocking.  If HPACK were used for HTTP/QUIC, it would induce head-of-line blocking due to built-in assumptions of a total ordering across frames on all streams.</p>
<p id="rfc.section.1.p.2">QUIC is described in <a href="#QUIC-TRANSPORT" class="xref">[QUIC-TRANSPORT]</a>.  The HTTP/QUIC mapping is described in <a href="#QUIC-HTTP" class="xref">[QUIC-HTTP]</a>. For a full description of HTTP/2, see <a href="#RFC7540" class="xref">[RFC7540]</a>. The description of HPACK is <a href="#RFC7541" class="xref">[RFC7541]</a>.</p>
<p id="rfc.section.1.p.3">QPACK reuses core concepts from HPACK, but is redesigned to allow correctness in the presence of out-of-order delivery, with flexibility for implementations to balance between resilience against head-of-line blocking and optimal compression ratio.  The design goals are to closely approach the compression ratio of HPACK with substantially less head-of-line blocking under the same loss conditions.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#header-tables" id="header-tables">Header Tables</a>
</h1>
<p id="rfc.section.2.p.1">Like HPACK, QPACK uses two tables for associating header fields to indexes.  The static table (see <a href="#table-static" class="xref">Section 2.1</a>) is predefined and contains common header fields (some of them with an empty value).  The dynamic table (see <a href="#table-dynamic" class="xref">Section 2.2</a>) built up over the course of the connection and can be used by the encoder to index header fields repeated in the encoded header lists.</p>
<p id="rfc.section.2.p.2">Unlike in HPACK, entries in the QPACK static and dynamic tables are addressed separately.  The following sections describe how entries in each table is addressed.</p>
<h2 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#table-static" id="table-static">Static Table</a>
</h2>
<p id="rfc.section.2.1.p.1">The static table consists of a predefined static list of header fields, each of which has a fixed index over time.  Its entries are defined in Appendix A of <a href="#RFC7541" class="xref">[RFC7541]</a>. Note that because HPACK did not use zero-based references, there is no value at index zero of the static table.</p>
<h2 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#table-dynamic" id="table-dynamic">Dynamic Table</a>
</h2>
<p id="rfc.section.2.2.p.1">The dynamic table consists of a list of header fields maintained in first-in, first-out order.  The dynamic table is initially empty.  Entries are added by instructions on the encoder stream (see <a href="#encoder-stream" class="xref">Section 5.2</a>).</p>
<p id="rfc.section.2.2.p.2">Before a new entry is added to the dynamic table, entries are evicted from the end of the dynamic table until the size of the dynamic table is less than or equal to (maximum size - new entry size) or until the table is empty.</p>
<p id="rfc.section.2.2.p.3">If the size of the new entry is less than or equal to the maximum size, that entry is added to the table.  It is an error to attempt to add an entry that is larger than the maximum size; this MUST be treated as a connection error of type <samp>HTTP_QPACK_DECOMPRESSION_FAILED</samp>.</p>
<p id="rfc.section.2.2.p.4">A new entry can reference an entry in the dynamic table that will be evicted when adding this new entry into the dynamic table.  Implementations are cautioned to avoid deleting the referenced name if the referenced entry is evicted from the dynamic table prior to inserting the new entry.</p>
<p id="rfc.section.2.2.p.5">The dynamic table can contain duplicate entries (i.e., entries with the same name and same value).  Therefore, duplicate entries MUST NOT be treated as an error by a decoder.</p>
<p id="rfc.section.2.2.p.6">The encoder decides how to update the dynamic table and as such can control how much memory is used by the dynamic table.  To limit the memory requirements of the decoder, the dynamic table size is strictly bounded.</p>
<p id="rfc.section.2.2.p.7">The decoder determines the maximum size that the encoder is permitted to use for the dynamic table.  In HTTP/QUIC, this value is determined by the SETTINGS_HEADER_TABLE_SIZE setting (see <a href="#configuration" class="xref">Section 4</a>).</p>
<p id="rfc.section.2.2.p.8">An encoder can choose to use less capacity than this maximum size (see <a href="#size-update" class="xref">Section 5.2.4</a>), but the chosen size MUST stay lower than or equal to the maximum set by the decoder.  Whenever the maximum size for the dynamic table is reduced, entries are evicted from the end of the dynamic table until the size of the dynamic table is less than or equal to the maximum size.</p>
<p id="rfc.section.2.2.p.9">This mechanism can be used to completely clear entries from the dynamic table by setting a maximum size of 0, which can subsequently be restored.</p>
<h3 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#indexing" id="indexing">Absolute and Relative Indexing</a>
</h3>
<p id="rfc.section.2.2.1.p.1">Each entry possesses both an absolute index which is fixed for the lifetime of that entry and a relative index which changes over time based on the context of the reference. The first entry inserted has an absolute index of &#8220;1&#8221;; indices increase sequentially with each insertion.</p>
<p id="rfc.section.2.2.1.p.2">The relative index begins at zero and increases in the opposite direction from the absolute index.  Determining which entry has a relative index of &#8220;0&#8221; depends on the context of the reference.</p>
<p id="rfc.section.2.2.1.p.3">On the encoder stream, a relative index of &#8220;0&#8221; always refers to the most recently inserted value in the dynamic table.  Note that this means the entry referenced by a given relative index will change while interpreting instructions on the encoder stream.</p>
<pre>
    +---+---------------+-----------+
    | n |      ...      |   d + 1   |  Absolute Index
    + - +---------------+ - - - - - +
    | 0 |      ...      | n - d - 1 |  Relative Index
    +---+---------------+-----------+
      ^                     |
      |                     V
Insertion Point         Dropping Point

n = count of entries inserted
d = count of entries dropped
</pre>
<p class="figure">Example Dynamic Table Indexing - Control Stream</p>
<p id="rfc.section.2.2.1.p.4">Because frames from request streams can be delivered out of order with instructions on the encoder stream, relative indices are relative to the Base Index at the beginning of the header block (see <a href="#absolute-index" class="xref">Section 5.4.1</a>). The Base Index is an absolute index. When interpreting the rest of the frame, the entry identified by Base Index has a relative index of zero.  The relative indices of entries do not change while interpreting headers on a request or push stream.</p>
<pre>
             Base Index
                 |
                 V
    +---+-----+-----+-----+-------+
    | n | n-1 | n-2 | ... |  d+1  |  Absolute Index
    +---+-----+  -  +-----+   -   +
              |  0  | ... | n-d-3 |  Relative Index
              +-----+-----+-------+

n = count of entries inserted
d = count of entries dropped
</pre>
<p class="figure">Example Dynamic Table Indexing - Request Stream</p>
<h3 id="rfc.section.2.2.2">
<a href="#rfc.section.2.2.2">2.2.2.</a> <a href="#post-base-indexing" id="post-base-indexing">Post-Base Indexing</a>
</h3>
<p id="rfc.section.2.2.2.p.1">A header block on the request stream can reference entries added after the entry identified by the Base Index. This allows an encoder to process a header block in a single pass and include references to entries added while processing this (or other) header blocks. Newly added entries are referenced using Post-Base instructions. Indices for Post-Base instructions increase in the same direction as absolute indices, but the zero value is one higher than the Base Index.</p>
<pre>
             Base Index
                 |
                 V
    +---+-----+-----+-----+-----+
    | n | n-1 | n-2 | ... | d+1 |  Absolute Index
    +---+-----+-----+-----+-----+
    | 1 |  0  |                    Post-Base Index
    +---+-----+

n = count of entries inserted
d = count of entries dropped
</pre>
<p class="figure">Dynamic Table Indexing - Post-Base References</p>
<p id="rfc.section.2.2.2.p.2">If the decoder encounters a reference to an entry which has already been dropped from the table or which is greater than the declared Largest Reference (see <a href="#absolute-index" class="xref">Section 5.4.1</a>), this MUST be treated as a stream error of type <samp>HTTP_QPACK_DECOMPRESSION_FAILED</samp> error code.  If this reference occurs on the encoder stream, this MUST be treated as a session error.</p>
<h2 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#overview-hol-avoidance" id="overview-hol-avoidance">Avoiding Head-of-Line Blocking in HTTP/QUIC</a>
</h2>
<p id="rfc.section.2.3.p.1">Because QUIC does not guarantee order between data on different streams, a header block might reference an entry in the dynamic table that has not yet been received.</p>
<p id="rfc.section.2.3.p.2">Each header block contains a Largest Reference which identifies the table state necessary for decoding. If the greatest absolute index in the dynamic table is less than the value of the Largest Reference, the stream is considered &#8220;blocked.&#8221;  While blocked, header field data should remain in the blocked stream&#8217;s flow control window.  When the Largest Reference is zero, the frame contains no references to the dynamic table and can always be processed immediately. A stream becomes unblocked when the greatest absolute index in the dynamic table becomes greater than or equal to the Largest Reference for all header blocks the decoder has started reading from the stream.  If a decoder encounters a header block where the actual largest reference is not equal to the largest reference declared in the prefix, it MAY treat this as a stream error of type HTTP_QPACK_DECOMPRESSION_FAILED.</p>
<p id="rfc.section.2.3.p.3">A decoder can permit the possibility of blocked streams by setting SETTINGS_QPACK_BLOCKED_STREAMS to a non-zero value (see <a href="#configuration" class="xref">Section 4</a>).  This setting specifies an upper bound on the number of streams which can be blocked.</p>
<p id="rfc.section.2.3.p.4">An encoder can decide whether to risk having a stream become blocked. If permitted by the value of SETTINGS_QPACK_BLOCKED_STREAMS, compression efficiency can be improved by referencing dynamic table entries that are still in transit, but if there is loss or reordering the stream can become blocked at the decoder.  An encoder avoids the risk of blocking by only referencing dynamic table entries which have been acknowledged, but this means using literals. Since literals make the header block larger, this can result in the encoder becoming blocked on congestion or flow control limits.</p>
<p id="rfc.section.2.3.p.5">An encoder MUST limit the number of streams which could become blocked to the value of SETTINGS_QPACK_BLOCKED_STREAMS at all times. Note that the decoder might not actually become blocked on every stream which risks becoming blocked.  If the decoder encounters more blocked streams than it promised to support, it SHOULD treat this as a stream error of type HTTP_QPACK_DECOMPRESSION_FAILED.</p>
<h3 id="rfc.section.2.3.1">
<a href="#rfc.section.2.3.1">2.3.1.</a> <a href="#state-synchronization" id="state-synchronization">State Synchronization</a>
</h3>
<p id="rfc.section.2.3.1.p.1">The decoder stream signals key events at the decoder that permit the encoder to track the decoder&#8217;s state.  These events are:</p>
<p></p>

<ul>
<li>Complete processing of a header block</li>
<li>Abandonment of a stream which might have remaining header blocks</li>
<li>Receipt of new dynamic table entries</li>
</ul>
<p id="rfc.section.2.3.1.p.3">Regardless of whether a header block contained blocking references, the knowledge that it has been processed permits the encoder to evict entries to which no unacknowledged references remain; see <a href="#blocked-eviction" class="xref">Section 7.3.1</a>.  When a stream is reset or abandoned, the indication that these header blocks will never be processed serves a similar function; see <a href="#stream-cancellation" class="xref">Section 5.3.3</a>.</p>
<p id="rfc.section.2.3.1.p.4">For the encoder to identify which dynamic table entries can be safely used without a stream becoming blocked, the encoder tracks the absolute index of the decoder&#8217;s Largest Known Received entry.</p>
<p id="rfc.section.2.3.1.p.5">When blocking references are permitted, the encoder uses acknowledgement of header blocks to identify the Largest Known Received index, as described in <a href="#header-acknowledgement" class="xref">Section 5.3.2</a>.</p>
<p id="rfc.section.2.3.1.p.6">To acknowledge dynamic table entries which are not referenced by header blocks, for example because the encoder or the decoder have chosen not to risk blocked streams, the decoder sends a Table State Synchronize instruction (see <a href="#table-state-synchronize" class="xref">Section 5.3.1</a>).</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#conventions-and-definitions" id="conventions-and-definitions">Conventions and Definitions</a>
</h1>
<p id="rfc.section.3.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.3.p.2">Definitions of terms that are used in this document:</p>
<p></p>

<dl>
<dt>Header:</dt>
<dd style="margin-left: 8">A name-value pair sent as part of an HTTP message.</dd>
<dt>Header set:</dt>
<dd style="margin-left: 8">The full collection of headers associated with an HTTP message.</dd>
<dt>Header block:</dt>
<dd style="margin-left: 8">The compressed representation of a header set.</dd>
<dt>Encoder:</dt>
<dd style="margin-left: 8">An implementation which transforms a header set into a header block.</dd>
<dt>Decoder:</dt>
<dd style="margin-left: 8">An implementation which transforms a header block into a header set.</dd>
</dl>
<p id="rfc.section.3.p.4">QPACK is a name, not an acronym.</p>
<h2 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a>
</h2>
<p id="rfc.section.3.1.p.1">Diagrams use the format described in Section 3.1 of <a href="#RFC2360" class="xref">[RFC2360]</a>, with the following additional conventions:</p>
<p></p>

<dl>
<dt>x (A)</dt>
<dd style="margin-left: 8">Indicates that x is A bits long</dd>
<dt>x (A+)</dt>
<dd style="margin-left: 8">Indicates that x uses the prefixed integer encoding defined in Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>, beginning with an A-bit prefix.</dd>
<dt>x &#8230;</dt>
<dd style="margin-left: 8">Indicates that x is variable-length and extends to the end of the region.</dd>
</dl>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#configuration" id="configuration">Configuration</a>
</h1>
<p id="rfc.section.4.p.1">QPACK defines two settings which are included in the HTTP/QUIC SETTINGS frame.</p>
<p></p>

<dl>
<dt>SETTINGS_HEADER_TABLE_SIZE (0x1):</dt>
<dd style="margin-left: 8">An integer with a maximum value of 2^30 - 1.  The default value is 4,096 bytes.  See <a href="#table-dynamic" class="xref">Section 2.2</a> for usage.</dd>
<dt>SETTINGS_QPACK_BLOCKED_STREAMS (0x7):</dt>
<dd style="margin-left: 8">An integer with a maximum value of 2^16 - 1.  The default value is 100.  See <a href="#overview-hol-avoidance" class="xref">Section 2.3</a>.</dd>
</dl>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#wire-format" id="wire-format">Wire Format</a>
</h1>
<p id="rfc.section.5.p.1">QPACK instructions occur in three locations, each of which uses a separate instruction space:</p>
<p></p>

<ul>
<li>The encoder stream is a unidirectional stream of type <samp>0x48</samp> (ASCII &#8216;H&#8217;) which carries table updates from encoder to decoder. Instructions on this stream modify the dynamic table state without generating output to any particular request.</li>
<li>The decoder stream is a unidirectional stream of type <samp>0x68</samp> (ASCII &#8216;h&#8217;) which carries acknowledgements of table modifications and header processing from decoder to encoder.</li>
<li>Finally, the contents of HEADERS and PUSH_PROMISE frames on request streams and push streams reference the QPACK table state.</li>
</ul>
<p id="rfc.section.5.p.3">There MUST be exactly one of each unidirectional stream type in each direction.  Receipt of a second instance of either stream type MUST be treated as a connection error of HTTP_WRONG_STREAM_COUNT.  Closure of either unidirectional stream MUST be treated as a connection error of type HTTP_CLOSED_CRITICAL_STREAM.</p>
<p id="rfc.section.5.p.4">This section describes the instructions which are possible on each stream type.</p>
<p id="rfc.section.5.p.5">All table updates occur on the encoder stream.  Request streams and push streams only carry header blocks that do not modify the state of the table.</p>
<h2 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#primitives" id="primitives">Primitives</a>
</h2>
<h3 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#prefixed-integers" id="prefixed-integers">Prefixed Integers</a>
</h3>
<p id="rfc.section.5.1.1.p.1">The prefixed integer from Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a> is used heavily throughout this document.  The format from <a href="#RFC7541" class="xref">[RFC7541]</a> is used unmodified.</p>
<h3 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#string-literals" id="string-literals">String Literals</a>
</h3>
<p id="rfc.section.5.1.2.p.1">The string literal defined by Section 5.2 of <a href="#RFC7541" class="xref">[RFC7541]</a> is also used throughout.  This string format includes optional Huffman encoding.</p>
<p id="rfc.section.5.1.2.p.2">HPACK defines string literals to begin on a byte boundary.  They begin with a single flag (indicating whether the string is Huffman-coded), followed by the Length encoded as a 7-bit prefix integer, and finally Length octets of data.  When Huffman encoding is enabled, the Huffman table from Appendix B of <a href="#RFC7541" class="xref">[RFC7541]</a> is used without modification.</p>
<p id="rfc.section.5.1.2.p.3">This document expands the definition of string literals and permits them to begin other than on a byte boundary.  An &#8220;N-bit prefix string literal&#8221; begins with the same Huffman flag, followed by the length encoded as an (N-1)-bit prefix integer.  The remainder of the string literal is unmodified.</p>
<p id="rfc.section.5.1.2.p.4">A string literal without a prefix length noted is an 8-bit prefix string literal and follows the definitions in <a href="#RFC7541" class="xref">[RFC7541]</a> without modification.</p>
<h2 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#encoder-stream" id="encoder-stream">QPACK Encoder Stream</a>
</h2>
<p id="rfc.section.5.2.p.1">Table updates can add a table entry, possibly using existing entries to avoid transmitting redundant information.  The name can be transmitted as a reference to an existing entry in the static or the dynamic table or as a string literal.  For entries which already exist in the dynamic table, the full entry can also be used by reference, creating a duplicate entry.</p>
<p id="rfc.section.5.2.p.2">The contents of the encoder stream are an unframed sequence of the following instructions.</p>
<h3 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#insert-with-name-reference" id="insert-with-name-reference">Insert With Name Reference</a>
</h3>
<p id="rfc.section.5.2.1.p.1">An addition to the header table where the header field name matches the header field name of an entry stored in the static table or the dynamic table starts with the &#8216;1&#8217; one-bit pattern.  The <samp>S</samp> bit indicates whether the reference is to the static (S=1) or dynamic (S=0) table. The 6-bit prefix integer (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>) that follows is used to locate the table entry for the header name.  When S=1, the number represents the static table index; when S=0, the number is the relative index of the entry in the dynamic table.</p>
<p id="rfc.section.5.2.1.p.2">The header name reference is followed by the header field value represented as a string literal (see Section 5.2 of <a href="#RFC7541" class="xref">[RFC7541]</a>).</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 | S |    Name Index (6+)    |
   +---+---+-----------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
</pre>
<p class="figure">Insert Header Field -- Indexed Name</p>
<h3 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#insert-without-name-reference" id="insert-without-name-reference">Insert Without Name Reference</a>
</h3>
<p id="rfc.section.5.2.2.p.1">An addition to the header table where both the header field name and the header field value are represented as string literals (see <a href="#primitives" class="xref">Section 5.1</a>) starts with the &#8216;01&#8217; two-bit pattern.</p>
<p id="rfc.section.5.2.2.p.2">The name is represented as a 6-bit prefix string literal, while the value is represented as an 8-bit prefix string literal.</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 | H | Name Length (5+)  |
   +---+---+---+-------------------+
   |  Name String (Length octets)  |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
</pre>
<p class="figure">Insert Header Field -- New Name</p>
<h3 id="rfc.section.5.2.3">
<a href="#rfc.section.5.2.3">5.2.3.</a> <a href="#duplicate" id="duplicate">Duplicate</a>
</h3>
<p id="rfc.section.5.2.3.p.1">Duplication of an existing entry in the dynamic table starts with the &#8216;000&#8217; three-bit pattern.  The relative index of the existing entry is represented as an integer with a 5-bit prefix.</p>
<div id="rfc.figure.1"></div>
<div id="fig-index-with-duplication"></div>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 | 0 |    Index (5+)     |
   +---+---+---+-------------------+
</pre>
<p class="figure">Figure 1: Duplicate</p>
<p id="rfc.section.5.2.3.p.2">The existing entry is re-inserted into the dynamic table without resending either the name or the value. This is useful to mitigate the eviction of older entries which are frequently referenced, both to avoid the need to resend the header and to avoid the entry in the table blocking the ability to insert new headers.</p>
<h3 id="rfc.section.5.2.4">
<a href="#rfc.section.5.2.4">5.2.4.</a> <a href="#size-update" id="size-update">Dynamic Table Size Update</a>
</h3>
<p id="rfc.section.5.2.4.p.1">An encoder informs the decoder of a change to the size of the dynamic table using an instruction which begins with the &#8216;001&#8217; three-bit pattern.  The new maximum table size is represented as an integer with a 5-bit prefix (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>).</p>
<div id="rfc.figure.2"></div>
<div id="fig-size-change"></div>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 |   Max size (5+)   |
+---+---+---+-------------------+
</pre>
<p class="figure">Figure 2: Maximum Dynamic Table Size Change</p>
<p id="rfc.section.5.2.4.p.2">The new maximum size MUST be lower than or equal to the limit determined by the protocol using QPACK.  A value that exceeds this limit MUST be treated as a decoding error.  In HTTP/QUIC, this limit is the value of the SETTINGS_HEADER_TABLE_SIZE parameter (see <a href="#configuration" class="xref">Section 4</a>) received from the decoder.</p>
<p id="rfc.section.5.2.4.p.3">Reducing the maximum size of the dynamic table can cause entries to be evicted (see Section 4.3 of <a href="#RFC7541" class="xref">[RFC7541]</a>).  This MUST NOT cause the eviction of entries with outstanding references (see <a href="#reference-tracking" class="xref">Section 7.3</a>).  Changing the size of the dynamic table is not acknowledged as this instruction does not insert an entry.</p>
<h2 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#feedback" id="feedback">QPACK Decoder Stream</a>
</h2>
<p id="rfc.section.5.3.p.1">The decoder stream carries information used to ensure consistency of the dynamic table. Information is sent from the QPACK decoder to the QPACK encoder; that is, the server informs the client about the processing of the client&#8217;s header blocks and table updates, and the client informs the server about the processing of the server&#8217;s header blocks and table updates.</p>
<p id="rfc.section.5.3.p.2">The contents of the decoder stream are an unframed sequence of the following instructions.</p>
<h3 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#table-state-synchronize" id="table-state-synchronize">Table State Synchronize</a>
</h3>
<p id="rfc.section.5.3.1.p.1">The Table State Synchronize instruction begins with the &#8216;00&#8217; two-bit pattern.  The instruction specifies the total number of dynamic table inserts and duplications since the last Table State Synchronize or Header Acknowledgement that increased the Largest Known Received dynamic table entry.  This is encoded as a 6-bit prefix integer. The encoder uses this value to determine which table entries might cause a stream to become blocked, as described in <a href="#state-synchronization" class="xref">Section 2.3.1</a>.</p>
<div id="rfc.figure.3"></div>
<div id="fig-size-sync"></div>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 |   Insert Count (6+)   |
+---+---+-----------------------+
</pre>
<p class="figure">Figure 3: Table State Synchronize</p>
<p id="rfc.section.5.3.1.p.2">A decoder chooses when to emit Table State Synchronize instructions. Emitting a Table State Synchronize after adding each new dynamic table entry will provide the most timely feedback to the encoder, but could be redundant with other decoder feedback. By delaying a Table State Synchronize, a decoder might be able to coalesce multiple Table State Synchronize instructions, or replace them entirely with Header Acknowledgements. However, delaying too long may lead to compression inefficiencies if the encoder waits for an entry to be acknowledged before using it.</p>
<h3 id="rfc.section.5.3.2">
<a href="#rfc.section.5.3.2">5.3.2.</a> <a href="#header-acknowledgement" id="header-acknowledgement">Header Acknowledgement</a>
</h3>
<p id="rfc.section.5.3.2.p.1">After processing a header block whose declared Largest Reference is not zero, the decoder emits a Header Acknowledgement instruction on the decoder stream.  The instruction begins with the &#8216;1&#8217; one-bit pattern and includes the request stream&#8217;s stream ID, encoded as a 7-bit prefix integer.  It is used by the peer&#8217;s QPACK encoder to know when it is safe to evict an entry.</p>
<p id="rfc.section.5.3.2.p.2">The same Stream ID can be identified multiple times, as multiple header blocks can be sent on a single stream in the case of intermediate responses, trailers, and pushed requests.  Since header frames on each stream are received and processed in order, this gives the encoder precise feedback on which header blocks within a stream have been fully processed.</p>
<div id="rfc.figure.4"></div>
<div id="fig-header-ack"></div>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |      Stream ID (7+)       |
+---+---------------------------+
</pre>
<p class="figure">Figure 4: Header Acknowledgement</p>
<p id="rfc.section.5.3.2.p.3">When blocking references are permitted, the encoder uses acknowledgement of header blocks to update the Largest Known Received index.  If a header block was potentially blocking, the acknowledgement implies that the decoder has received all dynamic table state necessary to process the header block.  If the Largest Reference of an acknowledged header block was greater than the encoder&#8217;s current Largest Known Received index, the block&#8217;s Largest Reference becomes the new Largest Known Received.</p>
<h3 id="rfc.section.5.3.3">
<a href="#rfc.section.5.3.3">5.3.3.</a> <a href="#stream-cancellation" id="stream-cancellation">Stream Cancellation</a>
</h3>
<p id="rfc.section.5.3.3.p.1">A stream that is reset might have multiple outstanding header blocks.  A decoder that receives a stream reset before the end of a stream generates a Stream Cancellation instruction on the decoder stream.  Similarly, a decoder that abandons reading of a stream needs to signal this using the Stream Cancellation instruction.  This signals to the encoder that all references to the dynamic table on that stream are no longer outstanding.</p>
<p id="rfc.section.5.3.3.p.2">An encoder cannot infer from this instruction that any updates to the dynamic table have been received.</p>
<p id="rfc.section.5.3.3.p.3">The instruction begins with the &#8216;01&#8217; two-bit pattern. The instruction includes the stream ID of the affected stream - a request or push stream - encoded as a 6-bit prefix integer.</p>
<div id="rfc.figure.5"></div>
<div id="fig-stream-cancel"></div>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |     Stream ID (6+)    |
+---+---+-----------------------+
</pre>
<p class="figure">Figure 5: Stream Cancellation</p>
<h2 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#request-and-push-streams" id="request-and-push-streams">Request and Push Streams</a>
</h2>
<p id="rfc.section.5.4.p.1">HEADERS and PUSH_PROMISE frames on request and push streams reference the dynamic table in a particular state without modifying it.  Frames on these streams emit the headers for an HTTP request or response.</p>
<h3 id="rfc.section.5.4.1">
<a href="#rfc.section.5.4.1">5.4.1.</a> <a href="#absolute-index" id="absolute-index">Header Data Prefix</a>
</h3>
<p id="rfc.section.5.4.1.p.1">Header data is prefixed with two integers, <samp>Largest Reference</samp> and <samp>Base Index</samp>.</p>
<div id="rfc.figure.6"></div>
<div id="fig-base-index"></div>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|     Largest Reference (8+)    |
+---+---------------------------+
| S |   Delta Base Index (7+)   |
+---+---------------------------+
|      Compressed Headers     ...
+-------------------------------+
</pre>
<p class="figure">Figure 6: Frame Payload</p>
<p><samp>Largest Reference</samp> identifies the largest absolute dynamic index referenced in the block.  Blocking decoders use the Largest Reference to determine when it is safe to process the rest of the block.</p>
<p><samp>Base Index</samp> is used to resolve references in the dynamic table as described in <a href="#indexing" class="xref">Section 2.2.1</a>.</p>
<p id="rfc.section.5.4.1.p.4">To save space, Base Index is encoded relative to Largest Reference using a one-bit sign and the <samp>Delta Base Index</samp> value.  A sign bit of 0 indicates that the Base Index has an absolute index that is greater than or equal to the Largest Reference; the value of Delta Base Index is added to the Largest Reference to determine the absolute value of the Base Index.  A sign bit of 1 indicates that the Base Index is less than the Largest Reference.  That is:</p>
<pre>
   if sign == 0:
      baseIndex = largestReference + deltaBaseIndex
   else:
      baseIndex = largestReference - deltaBaseIndex
</pre>
<p id="rfc.section.5.4.1.p.5">A single-pass encoder is expected to determine the absolute value of Base Index before encoding a header block.  If the encoder inserted entries in the dynamic table while encoding the header block, Largest Reference will be greater than Base Index, so the encoded difference is negative and the sign bit is set to 1.  If the header block did not reference the most recent entry in the table and did not insert any new entries, Base Index will be greater than the Largest Reference, so the delta will be positive and the sign bit is set to 0.</p>
<p id="rfc.section.5.4.1.p.6">An encoder that produces table updates before encoding a header block might set Largest Reference and Base Index to the same value.  When Largest Reference and Base Index are equal, the Delta Base Index is encoded with a zero sign bit.  A sign bit set to 1 when the Delta Base Index is 0 MUST be treated as a decoder error.</p>
<p id="rfc.section.5.4.1.p.7">A header block that does not reference the dynamic table can use any value for Base Index; setting both Largest Reference and Base Index to zero is the most efficient encoding.</p>
<h3 id="rfc.section.5.4.2">
<a href="#rfc.section.5.4.2">5.4.2.</a> <a href="#instructions" id="instructions">Instructions</a>
</h3>
<h4 id="rfc.section.5.4.2.1">
<a href="#rfc.section.5.4.2.1">5.4.2.1.</a> <a href="#indexed-header-field" id="indexed-header-field">Indexed Header Field</a>
</h4>
<p id="rfc.section.5.4.2.1.p.1">An indexed header field representation identifies an entry in either the static table or the dynamic table and causes that header field to be added to the decoded header list, as described in Section 3.2 of <a href="#RFC7541" class="xref">[RFC7541]</a>.</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 | S |      Index (6+)       |
+---+---+-----------------------+
</pre>
<p class="figure">Indexed Header Field</p>
<p id="rfc.section.5.4.2.1.p.2">If the entry is in the static table, or in the dynamic table with an absolute index less than or equal to Base Index, this representation starts with the &#8216;1&#8217; 1-bit pattern, followed by the <samp>S</samp> bit indicating whether the reference is into the static (S=1) or dynamic (S=0) table. Finally, the relative index of the matching header field is represented as an integer with a 6-bit prefix (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>).</p>
<h4 id="rfc.section.5.4.2.2">
<a href="#rfc.section.5.4.2.2">5.4.2.2.</a> <a href="#indexed-header-field-with-post-base-index" id="indexed-header-field-with-post-base-index">Indexed Header Field With Post-Base Index</a>
</h4>
<p id="rfc.section.5.4.2.2.p.1">If the entry is in the dynamic table with an absolute index greater than Base Index, the representation starts with the &#8216;0001&#8217; 4-bit pattern, followed by the post-base index (see <a href="#post-base-indexing" class="xref">Section 2.2.2</a>) of the matching header field, represented as an integer with a 4-bit prefix (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>).</p>
<pre>
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |  Index (4+)   |
+---+---+---+---+---------------+
</pre>
<p class="figure">Indexed Header Field with Post-Base Index</p>
<h4 id="rfc.section.5.4.2.3">
<a href="#rfc.section.5.4.2.3">5.4.2.3.</a> <a href="#literal-header-field-with-name-reference" id="literal-header-field-with-name-reference">Literal Header Field With Name Reference</a>
</h4>
<p id="rfc.section.5.4.2.3.p.1">A literal header field with a name reference represents a header where the header field name matches the header field name of an entry stored in the static table or the dynamic table.</p>
<p id="rfc.section.5.4.2.3.p.2">If the entry is in the static table, or in the dynamic table with an absolute index less than or equal to Base Index, this representation starts with the &#8216;01&#8217; two-bit pattern.  If the entry is in the dynamic table with an absolute index greater than Base Index, the representation starts with the &#8216;0000&#8217; four-bit pattern.</p>
<p id="rfc.section.5.4.2.3.p.3">The following bit, &#8216;N&#8217;, indicates whether an intermediary is permitted to add this header to the dynamic header table on subsequent hops. When the &#8216;N&#8217; bit is set, the encoded header MUST always be encoded with a literal representation. In particular, when a peer sends a header field that it received represented as a literal header field with the &#8216;N&#8217; bit set, it MUST use a literal representation to forward this header field.  This bit is intended for protecting header field values that are not to be put at risk by compressing them (see Section 7.1 of <a href="#RFC7541" class="xref">[RFC7541]</a> for more details).</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 1 | N | S |Name Index (4+)|
   +---+---+---+---+---------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
</pre>
<p class="figure">Literal Header Field With Name Reference</p>
<p id="rfc.section.5.4.2.3.p.4">For entries in the static table or in the dynamic table with an absolute index less than or equal to Base Index, the header field name is represented using the relative index of that entry, which is represented as an integer with a 4-bit prefix (see Section 5.1 of <a href="#RFC7541" class="xref">[RFC7541]</a>). The <samp>S</samp> bit indicates whether the reference is to the static (S=1) or dynamic (S=0) table.</p>
<h4 id="rfc.section.5.4.2.4">
<a href="#rfc.section.5.4.2.4">5.4.2.4.</a> <a href="#literal-header-field-with-post-base-name-reference" id="literal-header-field-with-post-base-name-reference">Literal Header Field With Post-Base Name Reference</a>
</h4>
<p id="rfc.section.5.4.2.4.p.1">For entries in the dynamic table with an absolute index greater than Base Index, the header field name is represented using the post-base index of that entry (see <a href="#post-base-indexing" class="xref">Section 2.2.2</a>) encoded as an integer with a 3-bit prefix.</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 | 0 | 0 | N |NameIdx(3+)|
   +---+---+---+---+---+-----------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
</pre>
<p class="figure">Literal Header Field With Post-Base Name Reference</p>
<h4 id="rfc.section.5.4.2.5">
<a href="#rfc.section.5.4.2.5">5.4.2.5.</a> <a href="#literal-header-field-without-name-reference" id="literal-header-field-without-name-reference">Literal Header Field Without Name Reference</a>
</h4>
<p id="rfc.section.5.4.2.5.p.1">An addition to the header table where both the header field name and the header field value are represented as string literals (see <a href="#primitives" class="xref">Section 5.1</a>) starts with the &#8216;001&#8217; three-bit pattern.</p>
<p id="rfc.section.5.4.2.5.p.2">The fourth bit, &#8216;N&#8217;, indicates whether an intermediary is permitted to add this header to the dynamic header table on subsequent hops. When the &#8216;N&#8217; bit is set, the encoded header MUST always be encoded with a literal representation. In particular, when a peer sends a header field that it received represented as a literal header field with the &#8216;N&#8217; bit set, it MUST use a literal representation to forward this header field.  This bit is intended for protecting header field values that are not to be put at risk by compressing them (see Section 7.1 of <a href="#RFC7541" class="xref">[RFC7541]</a> for more details).</p>
<p id="rfc.section.5.4.2.5.p.3">The name is represented as a 4-bit prefix string literal, while the value is represented as an 8-bit prefix string literal.</p>
<pre>
     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 | 1 | N | H |NameLen(3+)|
   +---+---+---+---+---+-----------+
   |  Name String (Length octets)  |
   +---+---------------------------+
   | H |     Value Length (7+)     |
   +---+---------------------------+
   | Value String (Length octets)  |
   +-------------------------------+
</pre>
<p class="figure">Literal Header Field Without Name Reference</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#error-handling" id="error-handling">Error Handling</a>
</h1>
<p id="rfc.section.6.p.1">The following error code is defined for HTTP/QUIC to indicate all failures of QPACK which prevent the stream or connection from continuing:</p>
<p></p>

<dl>
<dt>HTTP_QPACK_DECOMPRESSION_FAILED (0x06):</dt>
<dd style="margin-left: 8">QPACK failed to decompress a frame and cannot continue.</dd>
</dl>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#encoding-strategies" id="encoding-strategies">Encoding Strategies</a>
</h1>
<h2 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#single-pass-encoding" id="single-pass-encoding">Single Pass Encoding</a>
</h2>
<p id="rfc.section.7.1.p.1">An encoder making a single pass over a list of headers must choose Base Index before knowing Largest Reference.  When trying to reference a header inserted to the table after encoding has begun, the entry is encoded with different instructions that tell the decoder to use an absolute index greater than the Base Index.</p>
<h2 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#evictions" id="evictions">Preventing Eviction Races</a>
</h2>
<p id="rfc.section.7.2.p.1">Due to out-of-order arrival, QPACK&#8217;s eviction algorithm requires changes (relative to HPACK) to avoid the possibility that an indexed representation is decoded after the referenced entry has already been evicted.  QPACK employs a two-phase eviction algorithm, in which the encoder will not evict entries that have outstanding (unacknowledged) references.</p>
<h2 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#reference-tracking" id="reference-tracking">Reference Tracking</a>
</h2>
<p id="rfc.section.7.3.p.1">An encoder MUST ensure that a header block which references a dynamic table entry is not received by the decoder after the referenced entry has already been evicted.  An encoder also respects the limit set by the decoder on the number of streams that are allowed to become blocked. Even if the decoder is willing to tolerate blocked streams, the encoder might choose to avoid them in certain cases.</p>
<p id="rfc.section.7.3.p.2">In order to enable this, the encoder will need to track outstanding (unacknowledged) header blocks and table updates using feedback received from the decoder.</p>
<h3 id="rfc.section.7.3.1">
<a href="#rfc.section.7.3.1">7.3.1.</a> <a href="#blocked-eviction" id="blocked-eviction">Blocked Eviction</a>
</h3>
<p id="rfc.section.7.3.1.p.1">The encoder MUST NOT permit an entry to be evicted while a reference to that entry remains unacknowledged.  If a new header to be inserted into the dynamic table would cause the eviction of such an entry, the encoder MUST NOT emit the insert instruction until the reference has been processed by the decoder and acknowledged.</p>
<p id="rfc.section.7.3.1.p.2">The encoder can emit a literal representation for the new header in order to avoid encoding delays, and MAY insert the header into the table later if desired.</p>
<p id="rfc.section.7.3.1.p.3">To ensure that the blocked eviction case is rare, references to the oldest entries in the dynamic table SHOULD be avoided.  When one of the oldest entries in the table is still actively used for references, the encoder SHOULD emit an Duplicate representation instead (see <a href="#duplicate" class="xref">Section 5.2.3</a>).</p>
<h3 id="rfc.section.7.3.2">
<a href="#rfc.section.7.3.2">7.3.2.</a> <a href="#blocked-decoding" id="blocked-decoding">Blocked Decoding</a>
</h3>
<p id="rfc.section.7.3.2.p.1">For header blocks encoded in non-blocking mode, the encoder needs to forego indexed representations that refer to table updates which have not yet been acknowledged with <a href="#feedback" class="xref">Section 5.3</a>.  Since all table updates are processed in sequence on the encoder stream, an index into the dynamic table is sufficient to track which entries have been acknowledged.</p>
<p id="rfc.section.7.3.2.p.2">To track blocked streams, the necessary Base Index value for each stream can be used.  Whenever the decoder processes a table update, it can begin decoding any blocked streams that now have their dependencies satisfied.</p>
<h2 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#speculative-updates" id="speculative-updates">Speculative table updates</a>
</h2>
<p id="rfc.section.7.4.p.1">Implementations can <em>speculatively</em> send header frames on the HTTP Control Streams which are not needed for any current HTTP request or response.  Such headers could be used strategically to improve performance.  For instance, the encoder might decide to <em>refresh</em> by sending Duplicate representations for popular header fields (<a href="#duplicate" class="xref">Section 5.2.3</a>), ensuring they have small indices and hence minimal size on the wire.</p>
<h2 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> <a href="#sample-one-pass-encoding-algorithm" id="sample-one-pass-encoding-algorithm">Sample One Pass Encoding Algorithm</a>
</h2>
<p id="rfc.section.7.5.p.1">Pseudo-code for single pass encoding, excluding handling of duplicates, non-blocking mode, and reference tracking.</p>
<pre>
baseIndex = dynamicTable.baseIndex
largestReference = 0
for header in headers:
  staticIdx = staticTable.getIndex(header)
  if staticIdx:
    encodeIndexReference(streamBuffer, staticIdx)
    continue

  dynamicIdx = dynamicTable.getIndex(header)
  if !dynamicIdx:
    # No matching entry.  Either insert+index or encode literal
    nameIdx = getNameIndex(header)
    if shouldIndex(header) and dynamicTable.canIndex(header):
      encodeLiteralWithIncrementalIndex(controlBuffer, nameIdx,
                                        header)
      dynamicTable.add(header)
      dynamicIdx = dynamicTable.baseIndex

  if !dynamicIdx:
    # Couldn't index it, literal
    if nameIdx &lt;= staticTable.size:
      encodeLiteral(streamBuffer, nameIndex, header)
    else:
      # encode literal, possibly with nameIdx above baseIndex
      encodeDynamicLiteral(streamBuffer, nameIndex, baseIndex,
                           header)
      largestReference = max(largestReference,
                             dynamicTable.toAbsolute(nameIdx))
  else:
    # Dynamic index reference
    assert(dynamicIdx)
    largestReference = max(largestReference, dynamicIdx)
    # Encode dynamicIdx, possibly with dynamicIdx above baseIndex
    encodeDynamicIndexReference(streamBuffer, dynamicIdx,
                                baseIndex)

# encode the prefix
encodeInteger(prefixBuffer, 0x00, largestReference, 8)
if baseIndex &gt;= largestReference:
  encodeInteger(prefixBuffer, 0, baseIndex - largestReference, 7)
else:
  encodeInteger(prefixBuffer, 0x80,
                largestReference  - baseIndex, 7)

return controlBuffer, prefixBuffer + streamBuffer
</pre>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.8.p.1">TBD.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<h2 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#settings-registration" id="settings-registration">Settings Registration</a>
</h2>
<p id="rfc.section.9.1.p.1">This document creates two new settings in the &#8220;HTTP/QUIC Settings&#8221; registry established in <a href="#QUIC-HTTP" class="xref">[QUIC-HTTP]</a>.</p>
<p id="rfc.section.9.1.p.2">The entries in the following table are registered by this document.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Setting Name</th>
<th class="center">Code</th>
<th class="left">Specification</th>
</tr></thead>
<tbody>
<tr>
<td class="left">HEADER_TABLE_SIZE</td>
<td class="center">0x1</td>
<td class="left"><a href="#configuration" class="xref">Section 4</a></td>
</tr>
<tr>
<td class="left">QPACK_BLOCKED_STREAMS</td>
<td class="center">0x7</td>
<td class="left"><a href="#configuration" class="xref">Section 4</a></td>
</tr>
</tbody>
</table>
<h2 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#stream-type-registration" id="stream-type-registration">Stream Type Registration</a>
</h2>
<p id="rfc.section.9.2.p.1">This document creates two new settings in the &#8220;HTTP/QUIC Stream Type&#8221; registry established in <a href="#QUIC-HTTP" class="xref">[QUIC-HTTP]</a>.</p>
<p id="rfc.section.9.2.p.2">The entries in the following table are registered by this document.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Stream Type</th>
<th class="center">Code</th>
<th class="left">Specification</th>
<th class="left">Sender</th>
</tr></thead>
<tbody>
<tr>
<td class="left">QPACK Encoder Stream</td>
<td class="center">0x48</td>
<td class="left"><a href="#wire-format" class="xref">Section 5</a></td>
<td class="left">Both</td>
</tr>
<tr>
<td class="left">QPACK Decoder Stream</td>
<td class="center">0x68</td>
<td class="left"><a href="#wire-format" class="xref">Section 5</a></td>
<td class="left">Both</td>
</tr>
</tbody>
</table>
<h2 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#error-code-registration" id="error-code-registration">Error Code Registration</a>
</h2>
<p id="rfc.section.9.3.p.1">This document establishes one new error code in the &#8220;HTTP/QUIC Error Code&#8221; registry established in <a href="#QUIC-HTTP" class="xref">[QUIC-HTTP]</a>.</p>
<p></p>

<dl>
<dt>Name:</dt>
<dd style="margin-left: 8">HTTP_QPACK_DECOMPRESSION_FAILED</dd>
<dt>Code:</dt>
<dd style="margin-left: 8">0x06</dd>
<dt>Description:</dt>
<dd style="margin-left: 8">QPACK failed to interpret an instruction and cannot continue.</dd>
</dl>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> References</h1>
<h2 id="rfc.references.1">
<a href="#rfc.references.1">10.1.</a> Normative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="QUIC-HTTP">[QUIC-HTTP]</b></td>
<td class="top">
<a title="Akamai Technologies">Bishop, M.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-http">Hypertext Transfer Protocol (HTTP) over QUIC</a>", Internet-Draft draft-ietf-quic-http, August 2018.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</b></td>
<td class="top">
<a title="Fastly">Iyengar, J.</a> and <a title="Mozilla">M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport, August 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7541">[RFC7541]</b></td>
<td class="top">
<a>Peon, R.</a> and <a>H. Ruellan</a>, "<a href="https://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>", RFC 7541, DOI 10.17487/RFC7541, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h2 id="rfc.references.2">
<a href="#rfc.references.2">10.2.</a> Informative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2360">[RFC2360]</b></td>
<td class="top">
<a>Scott, G.</a>, "<a href="https://tools.ietf.org/html/rfc2360">Guide for Internet Standards Writers</a>", BCP 22, RFC 2360, DOI 10.17487/RFC2360, June 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7540">[RFC7540]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#change-log" id="change-log">Change Log</a>
</h1>
<p></p>

<ul class="empty"><li>
<strong>RFC Editor&#8217;s Note:</strong> Please remove this section prior to publication of a final version of this document.</li></ul>
<h2 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#since-draft-ietf-quic-qpack-01" id="since-draft-ietf-quic-qpack-01">Since draft-ietf-quic-qpack-01</a>
</h2>
<p></p>

<ul><li>Only header blocks that reference the dynamic table are acknowledged (#1603, #1605)</li></ul>
<h2 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#since-draft-ietf-quic-qpack-00" id="since-draft-ietf-quic-qpack-00">Since draft-ietf-quic-qpack-00</a>
</h2>
<p></p>

<ul>
<li>Renumbered instructions for consistency (#1471, #1472)</li>
<li>Decoder is allowed to validate largest reference (#1404, #1469)</li>
<li>Header block acknowledgments also acknowledge the associated largest reference (#1370, #1400)</li>
<li>Added an acknowledgment for unread streams (#1371, #1400)</li>
<li>Removed framing from encoder stream (#1361,#1467)</li>
<li>Control streams use typed unidirectional streams rather than fixed stream IDs (#910,#1359)</li>
</ul>
<h2 id="rfc.appendix.A.3">
<a href="#rfc.appendix.A.3">A.3.</a> <a href="#since-draft-ietf-quic-qcram-00" id="since-draft-ietf-quic-qcram-00">Since draft-ietf-quic-qcram-00</a>
</h2>
<p></p>

<ul>
<li>Separate instruction sets for table updates and header blocks (#1235, #1142, #1141)</li>
<li>Reworked indexing scheme (#1176, #1145, #1136, #1130, #1125, #1314)</li>
<li>Added mechanisms that support one-pass encoding (#1138, #1320)</li>
<li>Added a setting to control the number of blocked decoders (#238, #1140, #1143)</li>
<li>Moved table updates and acknowledgments to dedicated streams (#1121, #1122, #1238)</li>
</ul>
<h1 id="rfc.acknowledgments"><a href="#rfc.acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.B.p.1">This draft draws heavily on the text of <a href="#RFC7541" class="xref">[RFC7541]</a>.  The indirect input of those authors is gratefully acknowledged, as well as ideas from:</p>
<p></p>

<ul>
<li>Ryan Hamilton</li>
<li>Patrick McManus</li>
<li>Kazuho Oku</li>
<li>Biren Roy</li>
<li>Ian Swett</li>
<li>Dmitri Tikhonov</li>
</ul>
<p id="rfc.section.B.p.3">Buck&#8217;s contribution was supported by Google during his employment there.</p>
<p id="rfc.section.B.p.4">A substantial portion of Mike&#8217;s contribution was supported by Microsoft during his employment there.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Charles 'Buck' Krasic</span> 
	  <span class="n hidden">
		<span class="family-name">Krasic</span>
	  </span>
	</span>
	<span class="org vcardline">Netflix</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ckrasic@netflix.com">ckrasic@netflix.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> 
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline">Akamai Technologies</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mbishop@evequefou.be">mbishop@evequefou.be</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Alan Frindell</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Frindell</span>
	  </span>
	</span>
	<span class="org vcardline">Facebook</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:afrind@fb.com">afrind@fb.com</a></span>

  </address>
</div>

</body>
</html>
